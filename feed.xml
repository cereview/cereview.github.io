<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-05-05T01:23:41+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">amitabh yadav</title><subtitle>It&apos;s not right but the thing is, it&apos;s not even wrong!</subtitle><author><name>Amitabh Yadav</name></author><entry><title type="html">Formal Verification primer</title><link href="http://localhost:4000/posts/2022/formal-verification-primer/" rel="alternate" type="text/html" title="Formal Verification primer" /><published>2022-05-05T00:00:00+02:00</published><updated>2022-05-05T00:00:00+02:00</updated><id>http://localhost:4000/posts/2022/formal-verification-primer</id><content type="html" xml:base="http://localhost:4000/posts/2022/formal-verification-primer/"><![CDATA[<blockquote>
  <p>Formal verification (abbr. as FV) is the use of tools that mathematically analyze the space of possible behaviors of a design, rather than computing results for particular values.</p>
</blockquote>

<p>This means that FV tools will look a the full space of possible simulations (by using clever mathematical techniques) rather than trying out specific values. Today, FV is an essential element of the design and tapeout flow, specially in critial areas, that can help prevent dangerous bug escapes of potentially serious repurcussions (for example, <a href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">Intel FDIV bug from early 1990s</a>).</p>

<p>FV should be employed from the start of early development up through the post silicon debug process appropriately at every design phase to improve design throughput, increase the confidence in the design and reduce the time to market.</p>

<p>There are essentially many reasons to inculcate formal verification in your design flow. Some of them are as follow:</p>

<h3 id="references">References:</h3>
<ol>
  <li>Eric Seligman, Tom Schubert, M V Achutha Kiran Kumar, <em>Formal Verification: An Essential Toolkit for Modern VLSI Design</em>, Morgan Kaufmann publications by Elsevier Inc. (2015).</li>
</ol>

<h3 id="disclaimer">Disclaimer:</h3>
<p>A large part of the post are direct paraphrasing or direct quotations from the books and other online references. All credits are therefore attributed to the original authors. This post serves as a means to organize and present the useful infomation from different sources in a concise and practical way.</p>

<p>[This page is optimized for printing. Please consider saving paper by refraining from printing unless absolutely necessary.]</p>]]></content><author><name>Amitabh Yadav</name></author><category term="digital design and simulation" /><summary type="html"><![CDATA[Formal verification (abbr. as FV) is the use of tools that mathematically analyze the space of possible behaviors of a design, rather than computing results for particular values. This means that FV tools will look a the full space of possible simulations (by using clever mathematical techniques) rather than trying out specific values. Today, FV is an essential element of the design and tapeout flow, specially in critial areas, that can help prevent dangerous bug escapes of potentially serious repurcussions (for example, Intel FDIV bug from early 1990s). FV should be employed from the start of early development up through the post silicon debug process appropriately at every design phase to improve design throughput, increase the confidence in the design and reduce the time to market. There are essentially many reasons to inculcate formal verification in your design flow. Some of them are as follow: References: Eric Seligman, Tom Schubert, M V Achutha Kiran Kumar, Formal Verification: An Essential Toolkit for Modern VLSI Design, Morgan Kaufmann publications by Elsevier Inc. (2015). Disclaimer: A large part of the post are direct paraphrasing or direct quotations from the books and other online references. All credits are therefore attributed to the original authors. This post serves as a means to organize and present the useful infomation from different sources in a concise and practical way. [This page is optimized for printing. Please consider saving paper by refraining from printing unless absolutely necessary.]]]></summary></entry><entry><title type="html">Tcl Scripting Tutorial for Vivado</title><link href="http://localhost:4000/posts/2022/tcl-scripting-in-vivado/" rel="alternate" type="text/html" title="Tcl Scripting Tutorial for Vivado" /><published>2022-05-05T00:00:00+02:00</published><updated>2022-05-05T00:00:00+02:00</updated><id>http://localhost:4000/posts/2022/tcl-scripting-in-vivado</id><content type="html" xml:base="http://localhost:4000/posts/2022/tcl-scripting-in-vivado/"><![CDATA[<p>Tcl is Tool Command Language! <em>lol! I really didn’t know that.</em></p>

<p>It’s an interpreted programming language with variables, procedures (procs), and control structures. It has been adopted as the standard application programming interface, or API, among most EDA vendors to control and extend their applications. The Tcl interpreter inside the Vivado Design Suite provides the full power and flexibility of Tcl to control the application, access design objects and their properties, and create custom reports.</p>

<p>Xilinx Design Constraints (XDC) to specify the design constraints. XDC is based on a subset of all the Tcl commands available in Vivado and is interpreted exactly like Tcl. The XDC commands are primarily timing constraints, physical constraints, object queries and a few Tcl built-in commands: <code class="language-plaintext highlighter-rouge">set</code>, <code class="language-plaintext highlighter-rouge">list</code>, and <code class="language-plaintext highlighter-rouge">expr</code>.</p>

<p>The Vivado tools write a journal file called <code class="language-plaintext highlighter-rouge">vivado.jou</code> into the directory from which Vivado was launched. The journal is a record of the Tcl commands run during the session that can be used as a starting point to create new Tcl scripts.</p>

<p>A log file, <code class="language-plaintext highlighter-rouge">vivado.log</code> is also created by the tool and includes the output of the commands that are executed. Both the journal and log file are useful to verify which commands were run and what result they produced.</p>

<p>[ This document is a work in progress until May 30, 2022. The content already published as correct and up to date. ]</p>

<h3 id="references">References:</h3>
<p>This tutorial is primarily based on:</p>
<ol>
  <li>Xilinx Document# <a href="https://docs.xilinx.com/r/2021.2-English/ug894-vivado-tcl-scripting/Tcl-Scripting-in-Vivado">UG894 (v2021.2) Using Tcl Scripting</a> and,</li>
  <li><a href="https://docs.xilinx.com/r/2021.2-English/ug835-vivado-tcl-commands/Introduction">UG835 (v2021.2) Vivado Design Suite Tcl Command Reference Guide</a>.</li>
</ol>]]></content><author><name>Amitabh Yadav</name></author><category term="digital design and simulation" /><summary type="html"><![CDATA[Tcl is Tool Command Language! lol! I really didn’t know that. It’s an interpreted programming language with variables, procedures (procs), and control structures. It has been adopted as the standard application programming interface, or API, among most EDA vendors to control and extend their applications. The Tcl interpreter inside the Vivado Design Suite provides the full power and flexibility of Tcl to control the application, access design objects and their properties, and create custom reports. Xilinx Design Constraints (XDC) to specify the design constraints. XDC is based on a subset of all the Tcl commands available in Vivado and is interpreted exactly like Tcl. The XDC commands are primarily timing constraints, physical constraints, object queries and a few Tcl built-in commands: set, list, and expr. The Vivado tools write a journal file called vivado.jou into the directory from which Vivado was launched. The journal is a record of the Tcl commands run during the session that can be used as a starting point to create new Tcl scripts. A log file, vivado.log is also created by the tool and includes the output of the commands that are executed. Both the journal and log file are useful to verify which commands were run and what result they produced. [ This document is a work in progress until May 30, 2022. The content already published as correct and up to date. ] References: This tutorial is primarily based on: Xilinx Document# UG894 (v2021.2) Using Tcl Scripting and, UG835 (v2021.2) Vivado Design Suite Tcl Command Reference Guide.]]></summary></entry><entry><title type="html">Computer Arithmetic : In Depth</title><link href="http://localhost:4000/posts/2022/computer-arithmetic-in-depth/" rel="alternate" type="text/html" title="Computer Arithmetic : In Depth" /><published>2022-04-22T00:00:00+02:00</published><updated>2022-04-22T00:00:00+02:00</updated><id>http://localhost:4000/posts/2022/computer-arithmetic</id><content type="html" xml:base="http://localhost:4000/posts/2022/computer-arithmetic-in-depth/"><![CDATA[<h2 id="number-representation">Number Representation</h2>

<p>Conventional and oftentimes exotic methods of number representation can lead to performance gains in terms of simpler and faster circuits. While conventional methods are used extensively, the unconventional ones find application in special purpose digital circuits and systems.</p>

<blockquote>
  <p>Computer arithmetic deals with the hardware realization of arithmetic functions to support various computer architectures as well as with arithmetic algorithms for firmware or software implementation.</p>
</blockquote>

<p>A major thrust of digital computer arithmetic is the design of hardware algorithms and circuits to enhance the speed of numeric operations. Thus computer arithmetic complements the architectural and algorithmic speedup techniques for high-performance computer architecture design and parallel processing.</p>

<p>Objectives:</p>

<ul>
  <li>To be able to describe the core design elements of the Arithmetic and Logic Unit (ALUs) of top-of-the-line CPUs designed using high-performance parallel arithmetic circuits.</li>
  <li>At times we will also deal with slow bit-serial designs for embedded applications, where implementation cost and input/output pin limitations are of prime concern.</li>
  <li>It would be a mistake, though, to conclude that computer arithmetic is useful only to computer designers. We will see shortly that you can use scientific calculations more effectively and write programs that are more accurate and/or more efficient after a study of computer arithmetic.</li>
  <li>You will be able to render informed judgment when faced with the problem of choosing a digital signal processor chip for your project.</li>
</ul>

<h3 id="fixed-point-numbers">Fixed Point Numbers</h3>

<p><img src="/images/computer-arithmetic/scope-of-computer-arithmetic.png" alt="The scope of computer arithmetic" /></p>

<h3 id="references">References:</h3>

<ol>
  <li>Behrooz Parhami, <em>Computer Arithmetic: Algorithms and Hardware Designs</em>, 2nd Edition, Oxford University Press, New York, 2010.</li>
  <li>Henry S. Warren, Jr. , <em>Hacker’s Delight</em>, 2nd Edition, Addison-Wesley Professional, September 2012.</li>
</ol>]]></content><author><name>Amitabh Yadav</name></author><category term="computer arithmetic" /><summary type="html"><![CDATA[Number Representation Conventional and oftentimes exotic methods of number representation can lead to performance gains in terms of simpler and faster circuits. While conventional methods are used extensively, the unconventional ones find application in special purpose digital circuits and systems. Computer arithmetic deals with the hardware realization of arithmetic functions to support various computer architectures as well as with arithmetic algorithms for firmware or software implementation. A major thrust of digital computer arithmetic is the design of hardware algorithms and circuits to enhance the speed of numeric operations. Thus computer arithmetic complements the architectural and algorithmic speedup techniques for high-performance computer architecture design and parallel processing. Objectives: To be able to describe the core design elements of the Arithmetic and Logic Unit (ALUs) of top-of-the-line CPUs designed using high-performance parallel arithmetic circuits. At times we will also deal with slow bit-serial designs for embedded applications, where implementation cost and input/output pin limitations are of prime concern. It would be a mistake, though, to conclude that computer arithmetic is useful only to computer designers. We will see shortly that you can use scientific calculations more effectively and write programs that are more accurate and/or more efficient after a study of computer arithmetic. You will be able to render informed judgment when faced with the problem of choosing a digital signal processor chip for your project. Fixed Point Numbers References: Behrooz Parhami, Computer Arithmetic: Algorithms and Hardware Designs, 2nd Edition, Oxford University Press, New York, 2010. Henry S. Warren, Jr. , Hacker’s Delight, 2nd Edition, Addison-Wesley Professional, September 2012.]]></summary></entry></feed>